// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	resource "github.com/orange-cloudfoundry/gitlab-release-resource"
	gitlab "github.com/xanzy/go-gitlab"
)

type FakeGitLab struct {
	CreateReleaseStub        func(string, string, *string) (*gitlab.Release, error)
	createReleaseMutex       sync.RWMutex
	createReleaseArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 *string
	}
	createReleaseReturns struct {
		result1 *gitlab.Release
		result2 error
	}
	createReleaseReturnsOnCall map[int]struct {
		result1 *gitlab.Release
		result2 error
	}
	CreateReleaseLinkStub        func(string, string, string) (*gitlab.ReleaseLink, error)
	createReleaseLinkMutex       sync.RWMutex
	createReleaseLinkArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	createReleaseLinkReturns struct {
		result1 *gitlab.ReleaseLink
		result2 error
	}
	createReleaseLinkReturnsOnCall map[int]struct {
		result1 *gitlab.ReleaseLink
		result2 error
	}
	CreateTagStub        func(string, string) (*gitlab.Tag, error)
	createTagMutex       sync.RWMutex
	createTagArgsForCall []struct {
		arg1 string
		arg2 string
	}
	createTagReturns struct {
		result1 *gitlab.Tag
		result2 error
	}
	createTagReturnsOnCall map[int]struct {
		result1 *gitlab.Tag
		result2 error
	}
	DeleteReleaseLinkStub        func(string, *gitlab.ReleaseLink) error
	deleteReleaseLinkMutex       sync.RWMutex
	deleteReleaseLinkArgsForCall []struct {
		arg1 string
		arg2 *gitlab.ReleaseLink
	}
	deleteReleaseLinkReturns struct {
		result1 error
	}
	deleteReleaseLinkReturnsOnCall map[int]struct {
		result1 error
	}
	DownloadProjectFileStub        func(string, string) error
	downloadProjectFileMutex       sync.RWMutex
	downloadProjectFileArgsForCall []struct {
		arg1 string
		arg2 string
	}
	downloadProjectFileReturns struct {
		result1 error
	}
	downloadProjectFileReturnsOnCall map[int]struct {
		result1 error
	}
	GetReleaseStub        func(string) (*gitlab.Release, error)
	getReleaseMutex       sync.RWMutex
	getReleaseArgsForCall []struct {
		arg1 string
	}
	getReleaseReturns struct {
		result1 *gitlab.Release
		result2 error
	}
	getReleaseReturnsOnCall map[int]struct {
		result1 *gitlab.Release
		result2 error
	}
	GetReleaseLinksStub        func(string) ([]*gitlab.ReleaseLink, error)
	getReleaseLinksMutex       sync.RWMutex
	getReleaseLinksArgsForCall []struct {
		arg1 string
	}
	getReleaseLinksReturns struct {
		result1 []*gitlab.ReleaseLink
		result2 error
	}
	getReleaseLinksReturnsOnCall map[int]struct {
		result1 []*gitlab.ReleaseLink
		result2 error
	}
	GetTagStub        func(string) (*gitlab.Tag, error)
	getTagMutex       sync.RWMutex
	getTagArgsForCall []struct {
		arg1 string
	}
	getTagReturns struct {
		result1 *gitlab.Tag
		result2 error
	}
	getTagReturnsOnCall map[int]struct {
		result1 *gitlab.Tag
		result2 error
	}
	ListReleasesStub        func() ([]*gitlab.Release, error)
	listReleasesMutex       sync.RWMutex
	listReleasesArgsForCall []struct {
	}
	listReleasesReturns struct {
		result1 []*gitlab.Release
		result2 error
	}
	listReleasesReturnsOnCall map[int]struct {
		result1 []*gitlab.Release
		result2 error
	}
	ListTagsStub        func() ([]*gitlab.Tag, error)
	listTagsMutex       sync.RWMutex
	listTagsArgsForCall []struct {
	}
	listTagsReturns struct {
		result1 []*gitlab.Tag
		result2 error
	}
	listTagsReturnsOnCall map[int]struct {
		result1 []*gitlab.Tag
		result2 error
	}
	ListTagsUntilStub        func(string) ([]*gitlab.Tag, error)
	listTagsUntilMutex       sync.RWMutex
	listTagsUntilArgsForCall []struct {
		arg1 string
	}
	listTagsUntilReturns struct {
		result1 []*gitlab.Tag
		result2 error
	}
	listTagsUntilReturnsOnCall map[int]struct {
		result1 []*gitlab.Tag
		result2 error
	}
	UpdateReleaseStub        func(string, string, *string) (*gitlab.Release, error)
	updateReleaseMutex       sync.RWMutex
	updateReleaseArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 *string
	}
	updateReleaseReturns struct {
		result1 *gitlab.Release
		result2 error
	}
	updateReleaseReturnsOnCall map[int]struct {
		result1 *gitlab.Release
		result2 error
	}
	UploadProjectFileStub        func(string) (*gitlab.ProjectFile, error)
	uploadProjectFileMutex       sync.RWMutex
	uploadProjectFileArgsForCall []struct {
		arg1 string
	}
	uploadProjectFileReturns struct {
		result1 *gitlab.ProjectFile
		result2 error
	}
	uploadProjectFileReturnsOnCall map[int]struct {
		result1 *gitlab.ProjectFile
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeGitLab) CreateRelease(arg1 string, arg2 string, arg3 *string) (*gitlab.Release, error) {
	fake.createReleaseMutex.Lock()
	ret, specificReturn := fake.createReleaseReturnsOnCall[len(fake.createReleaseArgsForCall)]
	fake.createReleaseArgsForCall = append(fake.createReleaseArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 *string
	}{arg1, arg2, arg3})
	stub := fake.CreateReleaseStub
	fakeReturns := fake.createReleaseReturns
	fake.recordInvocation("CreateRelease", []interface{}{arg1, arg2, arg3})
	fake.createReleaseMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitLab) CreateReleaseCallCount() int {
	fake.createReleaseMutex.RLock()
	defer fake.createReleaseMutex.RUnlock()
	return len(fake.createReleaseArgsForCall)
}

func (fake *FakeGitLab) CreateReleaseCalls(stub func(string, string, *string) (*gitlab.Release, error)) {
	fake.createReleaseMutex.Lock()
	defer fake.createReleaseMutex.Unlock()
	fake.CreateReleaseStub = stub
}

func (fake *FakeGitLab) CreateReleaseArgsForCall(i int) (string, string, *string) {
	fake.createReleaseMutex.RLock()
	defer fake.createReleaseMutex.RUnlock()
	argsForCall := fake.createReleaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeGitLab) CreateReleaseReturns(result1 *gitlab.Release, result2 error) {
	fake.createReleaseMutex.Lock()
	defer fake.createReleaseMutex.Unlock()
	fake.CreateReleaseStub = nil
	fake.createReleaseReturns = struct {
		result1 *gitlab.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) CreateReleaseReturnsOnCall(i int, result1 *gitlab.Release, result2 error) {
	fake.createReleaseMutex.Lock()
	defer fake.createReleaseMutex.Unlock()
	fake.CreateReleaseStub = nil
	if fake.createReleaseReturnsOnCall == nil {
		fake.createReleaseReturnsOnCall = make(map[int]struct {
			result1 *gitlab.Release
			result2 error
		})
	}
	fake.createReleaseReturnsOnCall[i] = struct {
		result1 *gitlab.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) CreateReleaseLink(arg1 string, arg2 string, arg3 string) (*gitlab.ReleaseLink, error) {
	fake.createReleaseLinkMutex.Lock()
	ret, specificReturn := fake.createReleaseLinkReturnsOnCall[len(fake.createReleaseLinkArgsForCall)]
	fake.createReleaseLinkArgsForCall = append(fake.createReleaseLinkArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.CreateReleaseLinkStub
	fakeReturns := fake.createReleaseLinkReturns
	fake.recordInvocation("CreateReleaseLink", []interface{}{arg1, arg2, arg3})
	fake.createReleaseLinkMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitLab) CreateReleaseLinkCallCount() int {
	fake.createReleaseLinkMutex.RLock()
	defer fake.createReleaseLinkMutex.RUnlock()
	return len(fake.createReleaseLinkArgsForCall)
}

func (fake *FakeGitLab) CreateReleaseLinkCalls(stub func(string, string, string) (*gitlab.ReleaseLink, error)) {
	fake.createReleaseLinkMutex.Lock()
	defer fake.createReleaseLinkMutex.Unlock()
	fake.CreateReleaseLinkStub = stub
}

func (fake *FakeGitLab) CreateReleaseLinkArgsForCall(i int) (string, string, string) {
	fake.createReleaseLinkMutex.RLock()
	defer fake.createReleaseLinkMutex.RUnlock()
	argsForCall := fake.createReleaseLinkArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeGitLab) CreateReleaseLinkReturns(result1 *gitlab.ReleaseLink, result2 error) {
	fake.createReleaseLinkMutex.Lock()
	defer fake.createReleaseLinkMutex.Unlock()
	fake.CreateReleaseLinkStub = nil
	fake.createReleaseLinkReturns = struct {
		result1 *gitlab.ReleaseLink
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) CreateReleaseLinkReturnsOnCall(i int, result1 *gitlab.ReleaseLink, result2 error) {
	fake.createReleaseLinkMutex.Lock()
	defer fake.createReleaseLinkMutex.Unlock()
	fake.CreateReleaseLinkStub = nil
	if fake.createReleaseLinkReturnsOnCall == nil {
		fake.createReleaseLinkReturnsOnCall = make(map[int]struct {
			result1 *gitlab.ReleaseLink
			result2 error
		})
	}
	fake.createReleaseLinkReturnsOnCall[i] = struct {
		result1 *gitlab.ReleaseLink
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) CreateTag(arg1 string, arg2 string) (*gitlab.Tag, error) {
	fake.createTagMutex.Lock()
	ret, specificReturn := fake.createTagReturnsOnCall[len(fake.createTagArgsForCall)]
	fake.createTagArgsForCall = append(fake.createTagArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.CreateTagStub
	fakeReturns := fake.createTagReturns
	fake.recordInvocation("CreateTag", []interface{}{arg1, arg2})
	fake.createTagMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitLab) CreateTagCallCount() int {
	fake.createTagMutex.RLock()
	defer fake.createTagMutex.RUnlock()
	return len(fake.createTagArgsForCall)
}

func (fake *FakeGitLab) CreateTagCalls(stub func(string, string) (*gitlab.Tag, error)) {
	fake.createTagMutex.Lock()
	defer fake.createTagMutex.Unlock()
	fake.CreateTagStub = stub
}

func (fake *FakeGitLab) CreateTagArgsForCall(i int) (string, string) {
	fake.createTagMutex.RLock()
	defer fake.createTagMutex.RUnlock()
	argsForCall := fake.createTagArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGitLab) CreateTagReturns(result1 *gitlab.Tag, result2 error) {
	fake.createTagMutex.Lock()
	defer fake.createTagMutex.Unlock()
	fake.CreateTagStub = nil
	fake.createTagReturns = struct {
		result1 *gitlab.Tag
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) CreateTagReturnsOnCall(i int, result1 *gitlab.Tag, result2 error) {
	fake.createTagMutex.Lock()
	defer fake.createTagMutex.Unlock()
	fake.CreateTagStub = nil
	if fake.createTagReturnsOnCall == nil {
		fake.createTagReturnsOnCall = make(map[int]struct {
			result1 *gitlab.Tag
			result2 error
		})
	}
	fake.createTagReturnsOnCall[i] = struct {
		result1 *gitlab.Tag
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) DeleteReleaseLink(arg1 string, arg2 *gitlab.ReleaseLink) error {
	fake.deleteReleaseLinkMutex.Lock()
	ret, specificReturn := fake.deleteReleaseLinkReturnsOnCall[len(fake.deleteReleaseLinkArgsForCall)]
	fake.deleteReleaseLinkArgsForCall = append(fake.deleteReleaseLinkArgsForCall, struct {
		arg1 string
		arg2 *gitlab.ReleaseLink
	}{arg1, arg2})
	stub := fake.DeleteReleaseLinkStub
	fakeReturns := fake.deleteReleaseLinkReturns
	fake.recordInvocation("DeleteReleaseLink", []interface{}{arg1, arg2})
	fake.deleteReleaseLinkMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGitLab) DeleteReleaseLinkCallCount() int {
	fake.deleteReleaseLinkMutex.RLock()
	defer fake.deleteReleaseLinkMutex.RUnlock()
	return len(fake.deleteReleaseLinkArgsForCall)
}

func (fake *FakeGitLab) DeleteReleaseLinkCalls(stub func(string, *gitlab.ReleaseLink) error) {
	fake.deleteReleaseLinkMutex.Lock()
	defer fake.deleteReleaseLinkMutex.Unlock()
	fake.DeleteReleaseLinkStub = stub
}

func (fake *FakeGitLab) DeleteReleaseLinkArgsForCall(i int) (string, *gitlab.ReleaseLink) {
	fake.deleteReleaseLinkMutex.RLock()
	defer fake.deleteReleaseLinkMutex.RUnlock()
	argsForCall := fake.deleteReleaseLinkArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGitLab) DeleteReleaseLinkReturns(result1 error) {
	fake.deleteReleaseLinkMutex.Lock()
	defer fake.deleteReleaseLinkMutex.Unlock()
	fake.DeleteReleaseLinkStub = nil
	fake.deleteReleaseLinkReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitLab) DeleteReleaseLinkReturnsOnCall(i int, result1 error) {
	fake.deleteReleaseLinkMutex.Lock()
	defer fake.deleteReleaseLinkMutex.Unlock()
	fake.DeleteReleaseLinkStub = nil
	if fake.deleteReleaseLinkReturnsOnCall == nil {
		fake.deleteReleaseLinkReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReleaseLinkReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitLab) DownloadProjectFile(arg1 string, arg2 string) error {
	fake.downloadProjectFileMutex.Lock()
	ret, specificReturn := fake.downloadProjectFileReturnsOnCall[len(fake.downloadProjectFileArgsForCall)]
	fake.downloadProjectFileArgsForCall = append(fake.downloadProjectFileArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.DownloadProjectFileStub
	fakeReturns := fake.downloadProjectFileReturns
	fake.recordInvocation("DownloadProjectFile", []interface{}{arg1, arg2})
	fake.downloadProjectFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGitLab) DownloadProjectFileCallCount() int {
	fake.downloadProjectFileMutex.RLock()
	defer fake.downloadProjectFileMutex.RUnlock()
	return len(fake.downloadProjectFileArgsForCall)
}

func (fake *FakeGitLab) DownloadProjectFileCalls(stub func(string, string) error) {
	fake.downloadProjectFileMutex.Lock()
	defer fake.downloadProjectFileMutex.Unlock()
	fake.DownloadProjectFileStub = stub
}

func (fake *FakeGitLab) DownloadProjectFileArgsForCall(i int) (string, string) {
	fake.downloadProjectFileMutex.RLock()
	defer fake.downloadProjectFileMutex.RUnlock()
	argsForCall := fake.downloadProjectFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGitLab) DownloadProjectFileReturns(result1 error) {
	fake.downloadProjectFileMutex.Lock()
	defer fake.downloadProjectFileMutex.Unlock()
	fake.DownloadProjectFileStub = nil
	fake.downloadProjectFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitLab) DownloadProjectFileReturnsOnCall(i int, result1 error) {
	fake.downloadProjectFileMutex.Lock()
	defer fake.downloadProjectFileMutex.Unlock()
	fake.DownloadProjectFileStub = nil
	if fake.downloadProjectFileReturnsOnCall == nil {
		fake.downloadProjectFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.downloadProjectFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitLab) GetRelease(arg1 string) (*gitlab.Release, error) {
	fake.getReleaseMutex.Lock()
	ret, specificReturn := fake.getReleaseReturnsOnCall[len(fake.getReleaseArgsForCall)]
	fake.getReleaseArgsForCall = append(fake.getReleaseArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetReleaseStub
	fakeReturns := fake.getReleaseReturns
	fake.recordInvocation("GetRelease", []interface{}{arg1})
	fake.getReleaseMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitLab) GetReleaseCallCount() int {
	fake.getReleaseMutex.RLock()
	defer fake.getReleaseMutex.RUnlock()
	return len(fake.getReleaseArgsForCall)
}

func (fake *FakeGitLab) GetReleaseCalls(stub func(string) (*gitlab.Release, error)) {
	fake.getReleaseMutex.Lock()
	defer fake.getReleaseMutex.Unlock()
	fake.GetReleaseStub = stub
}

func (fake *FakeGitLab) GetReleaseArgsForCall(i int) string {
	fake.getReleaseMutex.RLock()
	defer fake.getReleaseMutex.RUnlock()
	argsForCall := fake.getReleaseArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGitLab) GetReleaseReturns(result1 *gitlab.Release, result2 error) {
	fake.getReleaseMutex.Lock()
	defer fake.getReleaseMutex.Unlock()
	fake.GetReleaseStub = nil
	fake.getReleaseReturns = struct {
		result1 *gitlab.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) GetReleaseReturnsOnCall(i int, result1 *gitlab.Release, result2 error) {
	fake.getReleaseMutex.Lock()
	defer fake.getReleaseMutex.Unlock()
	fake.GetReleaseStub = nil
	if fake.getReleaseReturnsOnCall == nil {
		fake.getReleaseReturnsOnCall = make(map[int]struct {
			result1 *gitlab.Release
			result2 error
		})
	}
	fake.getReleaseReturnsOnCall[i] = struct {
		result1 *gitlab.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) GetReleaseLinks(arg1 string) ([]*gitlab.ReleaseLink, error) {
	fake.getReleaseLinksMutex.Lock()
	ret, specificReturn := fake.getReleaseLinksReturnsOnCall[len(fake.getReleaseLinksArgsForCall)]
	fake.getReleaseLinksArgsForCall = append(fake.getReleaseLinksArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetReleaseLinksStub
	fakeReturns := fake.getReleaseLinksReturns
	fake.recordInvocation("GetReleaseLinks", []interface{}{arg1})
	fake.getReleaseLinksMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitLab) GetReleaseLinksCallCount() int {
	fake.getReleaseLinksMutex.RLock()
	defer fake.getReleaseLinksMutex.RUnlock()
	return len(fake.getReleaseLinksArgsForCall)
}

func (fake *FakeGitLab) GetReleaseLinksCalls(stub func(string) ([]*gitlab.ReleaseLink, error)) {
	fake.getReleaseLinksMutex.Lock()
	defer fake.getReleaseLinksMutex.Unlock()
	fake.GetReleaseLinksStub = stub
}

func (fake *FakeGitLab) GetReleaseLinksArgsForCall(i int) string {
	fake.getReleaseLinksMutex.RLock()
	defer fake.getReleaseLinksMutex.RUnlock()
	argsForCall := fake.getReleaseLinksArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGitLab) GetReleaseLinksReturns(result1 []*gitlab.ReleaseLink, result2 error) {
	fake.getReleaseLinksMutex.Lock()
	defer fake.getReleaseLinksMutex.Unlock()
	fake.GetReleaseLinksStub = nil
	fake.getReleaseLinksReturns = struct {
		result1 []*gitlab.ReleaseLink
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) GetReleaseLinksReturnsOnCall(i int, result1 []*gitlab.ReleaseLink, result2 error) {
	fake.getReleaseLinksMutex.Lock()
	defer fake.getReleaseLinksMutex.Unlock()
	fake.GetReleaseLinksStub = nil
	if fake.getReleaseLinksReturnsOnCall == nil {
		fake.getReleaseLinksReturnsOnCall = make(map[int]struct {
			result1 []*gitlab.ReleaseLink
			result2 error
		})
	}
	fake.getReleaseLinksReturnsOnCall[i] = struct {
		result1 []*gitlab.ReleaseLink
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) GetTag(arg1 string) (*gitlab.Tag, error) {
	fake.getTagMutex.Lock()
	ret, specificReturn := fake.getTagReturnsOnCall[len(fake.getTagArgsForCall)]
	fake.getTagArgsForCall = append(fake.getTagArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetTagStub
	fakeReturns := fake.getTagReturns
	fake.recordInvocation("GetTag", []interface{}{arg1})
	fake.getTagMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitLab) GetTagCallCount() int {
	fake.getTagMutex.RLock()
	defer fake.getTagMutex.RUnlock()
	return len(fake.getTagArgsForCall)
}

func (fake *FakeGitLab) GetTagCalls(stub func(string) (*gitlab.Tag, error)) {
	fake.getTagMutex.Lock()
	defer fake.getTagMutex.Unlock()
	fake.GetTagStub = stub
}

func (fake *FakeGitLab) GetTagArgsForCall(i int) string {
	fake.getTagMutex.RLock()
	defer fake.getTagMutex.RUnlock()
	argsForCall := fake.getTagArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGitLab) GetTagReturns(result1 *gitlab.Tag, result2 error) {
	fake.getTagMutex.Lock()
	defer fake.getTagMutex.Unlock()
	fake.GetTagStub = nil
	fake.getTagReturns = struct {
		result1 *gitlab.Tag
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) GetTagReturnsOnCall(i int, result1 *gitlab.Tag, result2 error) {
	fake.getTagMutex.Lock()
	defer fake.getTagMutex.Unlock()
	fake.GetTagStub = nil
	if fake.getTagReturnsOnCall == nil {
		fake.getTagReturnsOnCall = make(map[int]struct {
			result1 *gitlab.Tag
			result2 error
		})
	}
	fake.getTagReturnsOnCall[i] = struct {
		result1 *gitlab.Tag
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) ListReleases() ([]*gitlab.Release, error) {
	fake.listReleasesMutex.Lock()
	ret, specificReturn := fake.listReleasesReturnsOnCall[len(fake.listReleasesArgsForCall)]
	fake.listReleasesArgsForCall = append(fake.listReleasesArgsForCall, struct {
	}{})
	stub := fake.ListReleasesStub
	fakeReturns := fake.listReleasesReturns
	fake.recordInvocation("ListReleases", []interface{}{})
	fake.listReleasesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitLab) ListReleasesCallCount() int {
	fake.listReleasesMutex.RLock()
	defer fake.listReleasesMutex.RUnlock()
	return len(fake.listReleasesArgsForCall)
}

func (fake *FakeGitLab) ListReleasesCalls(stub func() ([]*gitlab.Release, error)) {
	fake.listReleasesMutex.Lock()
	defer fake.listReleasesMutex.Unlock()
	fake.ListReleasesStub = stub
}

func (fake *FakeGitLab) ListReleasesReturns(result1 []*gitlab.Release, result2 error) {
	fake.listReleasesMutex.Lock()
	defer fake.listReleasesMutex.Unlock()
	fake.ListReleasesStub = nil
	fake.listReleasesReturns = struct {
		result1 []*gitlab.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) ListReleasesReturnsOnCall(i int, result1 []*gitlab.Release, result2 error) {
	fake.listReleasesMutex.Lock()
	defer fake.listReleasesMutex.Unlock()
	fake.ListReleasesStub = nil
	if fake.listReleasesReturnsOnCall == nil {
		fake.listReleasesReturnsOnCall = make(map[int]struct {
			result1 []*gitlab.Release
			result2 error
		})
	}
	fake.listReleasesReturnsOnCall[i] = struct {
		result1 []*gitlab.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) ListTags() ([]*gitlab.Tag, error) {
	fake.listTagsMutex.Lock()
	ret, specificReturn := fake.listTagsReturnsOnCall[len(fake.listTagsArgsForCall)]
	fake.listTagsArgsForCall = append(fake.listTagsArgsForCall, struct {
	}{})
	stub := fake.ListTagsStub
	fakeReturns := fake.listTagsReturns
	fake.recordInvocation("ListTags", []interface{}{})
	fake.listTagsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitLab) ListTagsCallCount() int {
	fake.listTagsMutex.RLock()
	defer fake.listTagsMutex.RUnlock()
	return len(fake.listTagsArgsForCall)
}

func (fake *FakeGitLab) ListTagsCalls(stub func() ([]*gitlab.Tag, error)) {
	fake.listTagsMutex.Lock()
	defer fake.listTagsMutex.Unlock()
	fake.ListTagsStub = stub
}

func (fake *FakeGitLab) ListTagsReturns(result1 []*gitlab.Tag, result2 error) {
	fake.listTagsMutex.Lock()
	defer fake.listTagsMutex.Unlock()
	fake.ListTagsStub = nil
	fake.listTagsReturns = struct {
		result1 []*gitlab.Tag
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) ListTagsReturnsOnCall(i int, result1 []*gitlab.Tag, result2 error) {
	fake.listTagsMutex.Lock()
	defer fake.listTagsMutex.Unlock()
	fake.ListTagsStub = nil
	if fake.listTagsReturnsOnCall == nil {
		fake.listTagsReturnsOnCall = make(map[int]struct {
			result1 []*gitlab.Tag
			result2 error
		})
	}
	fake.listTagsReturnsOnCall[i] = struct {
		result1 []*gitlab.Tag
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) ListTagsUntil(arg1 string) ([]*gitlab.Tag, error) {
	fake.listTagsUntilMutex.Lock()
	ret, specificReturn := fake.listTagsUntilReturnsOnCall[len(fake.listTagsUntilArgsForCall)]
	fake.listTagsUntilArgsForCall = append(fake.listTagsUntilArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ListTagsUntilStub
	fakeReturns := fake.listTagsUntilReturns
	fake.recordInvocation("ListTagsUntil", []interface{}{arg1})
	fake.listTagsUntilMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitLab) ListTagsUntilCallCount() int {
	fake.listTagsUntilMutex.RLock()
	defer fake.listTagsUntilMutex.RUnlock()
	return len(fake.listTagsUntilArgsForCall)
}

func (fake *FakeGitLab) ListTagsUntilCalls(stub func(string) ([]*gitlab.Tag, error)) {
	fake.listTagsUntilMutex.Lock()
	defer fake.listTagsUntilMutex.Unlock()
	fake.ListTagsUntilStub = stub
}

func (fake *FakeGitLab) ListTagsUntilArgsForCall(i int) string {
	fake.listTagsUntilMutex.RLock()
	defer fake.listTagsUntilMutex.RUnlock()
	argsForCall := fake.listTagsUntilArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGitLab) ListTagsUntilReturns(result1 []*gitlab.Tag, result2 error) {
	fake.listTagsUntilMutex.Lock()
	defer fake.listTagsUntilMutex.Unlock()
	fake.ListTagsUntilStub = nil
	fake.listTagsUntilReturns = struct {
		result1 []*gitlab.Tag
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) ListTagsUntilReturnsOnCall(i int, result1 []*gitlab.Tag, result2 error) {
	fake.listTagsUntilMutex.Lock()
	defer fake.listTagsUntilMutex.Unlock()
	fake.ListTagsUntilStub = nil
	if fake.listTagsUntilReturnsOnCall == nil {
		fake.listTagsUntilReturnsOnCall = make(map[int]struct {
			result1 []*gitlab.Tag
			result2 error
		})
	}
	fake.listTagsUntilReturnsOnCall[i] = struct {
		result1 []*gitlab.Tag
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) UpdateRelease(arg1 string, arg2 string, arg3 *string) (*gitlab.Release, error) {
	fake.updateReleaseMutex.Lock()
	ret, specificReturn := fake.updateReleaseReturnsOnCall[len(fake.updateReleaseArgsForCall)]
	fake.updateReleaseArgsForCall = append(fake.updateReleaseArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 *string
	}{arg1, arg2, arg3})
	stub := fake.UpdateReleaseStub
	fakeReturns := fake.updateReleaseReturns
	fake.recordInvocation("UpdateRelease", []interface{}{arg1, arg2, arg3})
	fake.updateReleaseMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitLab) UpdateReleaseCallCount() int {
	fake.updateReleaseMutex.RLock()
	defer fake.updateReleaseMutex.RUnlock()
	return len(fake.updateReleaseArgsForCall)
}

func (fake *FakeGitLab) UpdateReleaseCalls(stub func(string, string, *string) (*gitlab.Release, error)) {
	fake.updateReleaseMutex.Lock()
	defer fake.updateReleaseMutex.Unlock()
	fake.UpdateReleaseStub = stub
}

func (fake *FakeGitLab) UpdateReleaseArgsForCall(i int) (string, string, *string) {
	fake.updateReleaseMutex.RLock()
	defer fake.updateReleaseMutex.RUnlock()
	argsForCall := fake.updateReleaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeGitLab) UpdateReleaseReturns(result1 *gitlab.Release, result2 error) {
	fake.updateReleaseMutex.Lock()
	defer fake.updateReleaseMutex.Unlock()
	fake.UpdateReleaseStub = nil
	fake.updateReleaseReturns = struct {
		result1 *gitlab.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) UpdateReleaseReturnsOnCall(i int, result1 *gitlab.Release, result2 error) {
	fake.updateReleaseMutex.Lock()
	defer fake.updateReleaseMutex.Unlock()
	fake.UpdateReleaseStub = nil
	if fake.updateReleaseReturnsOnCall == nil {
		fake.updateReleaseReturnsOnCall = make(map[int]struct {
			result1 *gitlab.Release
			result2 error
		})
	}
	fake.updateReleaseReturnsOnCall[i] = struct {
		result1 *gitlab.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) UploadProjectFile(arg1 string) (*gitlab.ProjectFile, error) {
	fake.uploadProjectFileMutex.Lock()
	ret, specificReturn := fake.uploadProjectFileReturnsOnCall[len(fake.uploadProjectFileArgsForCall)]
	fake.uploadProjectFileArgsForCall = append(fake.uploadProjectFileArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.UploadProjectFileStub
	fakeReturns := fake.uploadProjectFileReturns
	fake.recordInvocation("UploadProjectFile", []interface{}{arg1})
	fake.uploadProjectFileMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitLab) UploadProjectFileCallCount() int {
	fake.uploadProjectFileMutex.RLock()
	defer fake.uploadProjectFileMutex.RUnlock()
	return len(fake.uploadProjectFileArgsForCall)
}

func (fake *FakeGitLab) UploadProjectFileCalls(stub func(string) (*gitlab.ProjectFile, error)) {
	fake.uploadProjectFileMutex.Lock()
	defer fake.uploadProjectFileMutex.Unlock()
	fake.UploadProjectFileStub = stub
}

func (fake *FakeGitLab) UploadProjectFileArgsForCall(i int) string {
	fake.uploadProjectFileMutex.RLock()
	defer fake.uploadProjectFileMutex.RUnlock()
	argsForCall := fake.uploadProjectFileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGitLab) UploadProjectFileReturns(result1 *gitlab.ProjectFile, result2 error) {
	fake.uploadProjectFileMutex.Lock()
	defer fake.uploadProjectFileMutex.Unlock()
	fake.UploadProjectFileStub = nil
	fake.uploadProjectFileReturns = struct {
		result1 *gitlab.ProjectFile
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) UploadProjectFileReturnsOnCall(i int, result1 *gitlab.ProjectFile, result2 error) {
	fake.uploadProjectFileMutex.Lock()
	defer fake.uploadProjectFileMutex.Unlock()
	fake.UploadProjectFileStub = nil
	if fake.uploadProjectFileReturnsOnCall == nil {
		fake.uploadProjectFileReturnsOnCall = make(map[int]struct {
			result1 *gitlab.ProjectFile
			result2 error
		})
	}
	fake.uploadProjectFileReturnsOnCall[i] = struct {
		result1 *gitlab.ProjectFile
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createReleaseMutex.RLock()
	defer fake.createReleaseMutex.RUnlock()
	fake.createReleaseLinkMutex.RLock()
	defer fake.createReleaseLinkMutex.RUnlock()
	fake.createTagMutex.RLock()
	defer fake.createTagMutex.RUnlock()
	fake.deleteReleaseLinkMutex.RLock()
	defer fake.deleteReleaseLinkMutex.RUnlock()
	fake.downloadProjectFileMutex.RLock()
	defer fake.downloadProjectFileMutex.RUnlock()
	fake.getReleaseMutex.RLock()
	defer fake.getReleaseMutex.RUnlock()
	fake.getReleaseLinksMutex.RLock()
	defer fake.getReleaseLinksMutex.RUnlock()
	fake.getTagMutex.RLock()
	defer fake.getTagMutex.RUnlock()
	fake.listReleasesMutex.RLock()
	defer fake.listReleasesMutex.RUnlock()
	fake.listTagsMutex.RLock()
	defer fake.listTagsMutex.RUnlock()
	fake.listTagsUntilMutex.RLock()
	defer fake.listTagsUntilMutex.RUnlock()
	fake.updateReleaseMutex.RLock()
	defer fake.updateReleaseMutex.RUnlock()
	fake.uploadProjectFileMutex.RLock()
	defer fake.uploadProjectFileMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeGitLab) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ resource.GitLab = new(FakeGitLab)
